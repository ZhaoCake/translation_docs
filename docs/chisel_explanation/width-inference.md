---
layout: docs
title:  "Width Inference"
section: "chisel3"
---

# 位宽推断

Chisel 提供位宽推断来减少设计工作量。我们鼓励用户手动指定端口和寄存器的位宽以防止出现任何意外，但未指定的位宽将由 FIRRTL 编译器推断。

对于所有未指定位宽的电路组件，FIRRTL 编译器将推断保持其所有输入连接合法性所需的最小可能位宽。这里隐含的是推断是以 Chisel 中赋值语句从右到左的方式进行的，即从右侧到左侧。如果一个组件没有输入连接，且位宽未指定，则会抛出错误表明无法推断位宽。

对于未指定位宽的模块输入端口，推断的位宽是保持该模块所有实例的所有输入连接合法性所需的最小可能位宽。
基本类型的多路复用器表达式的位宽是其两个对应输入位宽的最大值。对于多路复用聚合类型的表达式，每个叶子子元素的生成位宽是其对应的两个输入叶子子元素位宽的最大值。
条件有效表达式的位宽是其输入表达式的位宽。完整的形式化描述请参见 [Firrtl 规范](https://github.com/freechipsproject/firrtl/blob/master/spec/spec.pdf)。

硬件运算符的输出位宽由以下规则集定义：

| 操作                                      | 位宽                             |
| ---------                                | ---------                        |
| `z = x + y` *或* `z = x +% y`           | `w(z) = max(w(x), w(y))`        |
| `z = x +& y`                            | `w(z) = max(w(x), w(y)) + 1`    |
| `z = x - y` *或* `z = x -% y`           | `w(z) = max(w(x), w(y))`        |
| `z = x -& y`                            | `w(z) = max(w(x), w(y)) + 1`    |
| `z = x & y`                             | `w(z) = max(w(x), w(y))`        |
| `z = Mux(c, x, y)`                      | `w(z) = max(w(x), w(y))`        |
| `z = w * y`                             | `w(z) = w(x) + w(y)`            |
| `z = x << n`                            | `w(z) = w(x) + maxNum(n)`       |
| `z = x >> n`                            | `w(z) = w(x) - minNum(n)`       |
| `z = Cat(x, y)`                         | `w(z) = w(x) + w(y)`            |
| `z = Fill(n, x)`                        | `w(z) = w(x) * maxNum(n)`       |

>其中例如 `w(z)` 是线 `z` 的位宽，而 `&` 规则适用于所有按位逻辑运算。

给定一个从未指定位宽元素（通常是顶层输入）开始的连接路径，编译器将抛出异常，指示某个位宽无法推断。

一个常见的"陷阱"来自于使用截断加法和减法操作符 `+` 和 `-`。希望结果保持加法或减法完整、扩展精度的用户应该使用扩展操作符 `+&` 和 `-&`。

> 默认的截断操作来自 Chisel 作为微处理器设计语言的历史。
